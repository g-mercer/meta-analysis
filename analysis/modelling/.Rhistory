# order by multiple_measurement shows that the correlation structure is fine
# looks odd above because of the order I input it into the dataframe
structure_check <- full_data_red_no_sim [order(full_data_red_no_sim$MULTIPLE_MEASUREMENT), ]
structure_check_matrix <- vcalc(vi = structure_check$LRR_VAR_INDIVIDUAL,
cluster = MULTIPLE_MEASUREMENT,
time1 = TIME_SIMPLE,
phi= 0.8,
data= structure_check)
corrplot::corrplot(cov2cor(structure_check_matrix) [1:50, 1:50])
corrplot::corrplot(cov2cor(structure_check_matrix) [50:100, 50:100])
corrplot::corrplot(cov2cor(structure_check_matrix) [100:150, 100:150])
corrplot::corrplot(cov2cor(structure_check_matrix) [150:200, 150:200])
corrplot::corrplot(cov2cor(structure_check_matrix) [200:250, 200:250])
corrplot::corrplot(cov2cor(structure_check_matrix) [250:300, 250:300])
corrplot::corrplot(cov2cor(structure_check_matrix) [300:348, 300:348])
vcalc_SE <- function (m, se, p1, data, cov_type = c("ROM", "LOR"))
{
cov_type <- match.arg(cov_type, choices = cov_type)
if (cov_type == "ROM") {
cov <- data[p1, se]^2/data[p1, m]^2
}
if (cov_type == "LOR") {
cov <- (1/data[p1, m] + 1)/(data[p1, n] - data[p1, m])
}
return(cov)
}
make_VCV_matrix_SE <- function (data, V, m, se, n, cluster, obs, type = c("vcv", "cor"),
vcal = c("none", "lnOR", "ROM"), rho = 0.5)
{
type <- match.arg(type, choices = type)
vcal <- match.arg(vcal, choices = vcal)
if (missing(data)) {
stop("Must specify dataframe via 'data' argument.")
}
if (missing(V)) {
stop("Must specify name of the variance variable via 'V' argument.")
}
if (missing(cluster)) {
stop("Must specify name of the clustering variable via 'cluster' argument.")
}
if (missing(obs)) {
obs <- 1:length(V)
}
if (missing(type)) {
type <- "vcv"
}
if (vcal != "none") {
if (missing(m) | missing(se)) {
stop("Must specify m and se arguments so that the covariance can be correctly calculated.")
}
}
new_matrix <- matrix(0, nrow = dim(data)[1], ncol = dim(data)[1])
rownames(new_matrix) <- data[, obs]
colnames(new_matrix) <- data[, obs]
tmp <- duplicated(data[, cluster])
shared_coord <- which(data[, cluster] %in% data[tmp, cluster] ==
TRUE)
combinations <- do.call("rbind", tapply(shared_coord, data[shared_coord,
cluster], function(x) t(utils::combn(x, 2))))
if (type == "vcv") {
for (i in 1:dim(combinations)[1]) {
p1 <- combinations[i, 1]
p2 <- combinations[i, 2]
if (vcal == "none") {
p1_p2_cov <- rho * sqrt(data[p1, V]) * sqrt(data[p2,
V])
}
else {
p1_p2_cov <- vcalc_SE(m, se, p1, data, cov_type = vcal)
}
new_matrix[p1, p2] <- p1_p2_cov
new_matrix[p2, p1] <- p1_p2_cov
}
diag(new_matrix) <- data[, V]
}
if (type == "cor") {
for (i in 1:dim(combinations)[1]) {
p1 <- combinations[i, 1]
p2 <- combinations[i, 2]
p1_p2_cov <- rho
new_matrix[p1, p2] <- p1_p2_cov
new_matrix[p2, p1] <- p1_p2_cov
}
diag(new_matrix) <- 1
}
return(new_matrix)
}
full_data_red_no_sim$obs <- 1:nrow(full_data_red_no_sim)
common_control_matrix <- make_VCV_matrix_SE(data = full_data_red_no_sim, V = "LRR_VAR_INDIVIDUAL", cluster = "COMMON_CONTROL", m = "AI_50",
se = "AI_SE_INDIVIDUAL", type = "vcv", vcal = "ROM", obs = "obs")
corrplot::corrplot(cov2cor(common_control_matrix) [1:50, 1:50])
corrplot::corrplot(cov2cor(common_control_matrix) [50:100, 50:100])
corrplot::corrplot(cov2cor(common_control_matrix) [100:150, 100:150])
corrplot::corrplot(cov2cor(common_control_matrix) [150:200, 150:200])
corrplot::corrplot(cov2cor(common_control_matrix) [200:250, 200:250])
corrplot::corrplot(cov2cor(common_control_matrix) [250:300, 250:300])
corrplot::corrplot(cov2cor(common_control_matrix) [300:348, 300:348])
taxa <- unique(as.character(full_data_red_no_sim$SPECIES_NAME_BINOMIAL))
# resolves names. A few of the names I had were older synonyms
resolved_names <- tnrs_match_names(taxa)
my_tree <- tol_induced_subtree(ott_ids = resolved_names$ott_id, label_format = "name")
plot(my_tree, type = "phylogram", cex = 0.3)
# add to df OTL species names
name_update <- cbind(unique(as.character(full_data_red_no_sim$SPECIES_NAME_BINOMIAL)), resolved_names$unique_name)
full_data_red_no_sim$SPECIES_NAME_BINOMIAL_OTL <- ""
for (i in 1:nrow(name_update)) {
for (j in 1:nrow(full_data_red_no_sim)) {
if (name_update [i, 1] == full_data_red_no_sim$SPECIES_NAME_BINOMIAL [j]) {
full_data_red_no_sim$SPECIES_NAME_BINOMIAL_OTL [j] <- name_update [i, 2]
}
}
}
# give updated names underscores to match species names in tree
full_data_red_no_sim$SPECIES_NAME_BINOMIAL_OTL <- gsub(" ", "_", full_data_red_no_sim$SPECIES_NAME_BINOMIAL_OTL)
tree_tip_label <- my_tree$tip.label
updated_species_list <- unique(full_data_red_no_sim$SPECIES_NAME_BINOMIAL_OTL)
# check if names from the raw data are not found in tree. Match up.
setdiff(tree_tip_label, updated_species_list)
library(ape)
# calculate branch lengths
my_tree <- ape::compute.brlen(my_tree, method = "Grafen", power = 1)
# use a randomization approach to deal with polytomies
my_tree <- ape::multi2di(my_tree, random = TRUE)
# create correlation matrix for analysis
phylo_cor <- vcv(my_tree, cor = T)
# with REML
final_model <- rma.mv(yi = LRR, V = autocorrelation_matrix,
mod = ~ 0 + PESTICIDE_CLASS,
random = list(~1 | STUDY_ID,
~ TIME_SIMPLE | MULTIPLE_MEASUREMENT),
struct = "AR",
data = full_data_red_no_sim, method = "REML", test = "t", dfs = "contain")
summary(final_model)
# RVE
robust(final_model, cluster = full_data_red_no_sim$STUDY_ID, clubSandwich = TRUE)
# ai and form with SE
se_imputation_df_ai <- cbind.data.frame(DATA_ID = full_dataset_reduced$DATA_ID,
ED_50 = full_dataset_reduced$AI_50,
SE = full_dataset_reduced$AI_SE_INDIVIDUAL,
FORM_AI = "AI")
se_imputation_df_form <- cbind.data.frame(DATA_ID = full_dataset_reduced$DATA_ID,
ED_50 = full_dataset_reduced$FORM_50,
SE = full_dataset_reduced$FORM_SE_INDIVIDUAL,
FORM_AI = "FORM")
# combine
se_imputation_df <- rbind.data.frame(se_imputation_df_ai, se_imputation_df_form)
se_imputation_df$FORM_AI <- as.factor(se_imputation_df$FORM_AI)
# is there a relationship between SE and ED50
plot(se_imputation_df$SE [!is.na(se_imputation_df$SE)] ~ se_imputation_df$ED_50 [!is.na(se_imputation_df$SE)])
# zoom in
plot(se_imputation_df$SE [(se_imputation_df$ED_50 < 2000) & (se_imputation_df$SE < 200) & (!is.na(se_imputation_df$SE))] ~ se_imputation_df$ED_50 [(se_imputation_df$ED_50 < 2000) & (se_imputation_df$SE < 200) & (!is.na(se_imputation_df$SE))])
# SE seems to increase with ED50. The data that needs to be imputed is non-random. Usually
# bigger ED50 values.
# express se as a proportion of ed50. This controls for the large range of ED50 values and SE getting larger with ED50
# for se/ed50
# this would make it unitless too (so the non-equivalent units would not matter)
se_imputation_df$SE_PROP_ED_50 <- se_imputation_df$SE / se_imputation_df$ED_50
# plot this proportion against the ED_50
plot(se_imputation_df$SE_PROP_ED_50 [!is.na(se_imputation_df$SE)] ~ se_imputation_df$ED_50 [!is.na(se_imputation_df$SE)])
# positive relationship seems to have disappeared
plot(se_imputation_df$SE_PROP_ED_50 [(se_imputation_df$ED_50 < 400) & (se_imputation_df$SE_PROP_ED_50 < 5) & (!is.na(se_imputation_df$SE))] ~ se_imputation_df$ED_50 [(se_imputation_df$ED_50 < 400) & (se_imputation_df$SE_PROP_ED_50 < 5) & (!is.na(se_imputation_df$SE))])
# se as a proportion of mean distribution
plot(density(se_imputation_df$SE_PROP_ED_50 [!is.na(se_imputation_df$SE)]))
plot(density(se_imputation_df$SE_PROP_ED_50 [!is.na(se_imputation_df$SE) & (se_imputation_df$SE_PROP_ED_50 < 1)]))
# estimate the distribution the SE_PROP_ED_50 follows instead of se
# fit a gamma distribution to the data
# for < 1 add [se_imputation_df$SE_PROP_ED_50 < 1]
SE_PROP_ED_50_gamma <- fitdist(se_imputation_df$SE_PROP_ED_50 [(!is.na(se_imputation_df$SE))],
distr = "gamma",
method = "mle")
summary(SE_PROP_ED_50_gamma)
# the > 1 values result in the odd qqplot.
plot(SE_PROP_ED_50_gamma)
# how many SEs do I need to impute in total? 113
nrow(rbind.data.frame(full_dataset_reduced [full_dataset_reduced$AI_ERROR_TYPE == "n/a", ],
full_dataset_reduced [full_dataset_reduced$FORM_ERROR_TYPE == "n/a", ]))
SE_PROP_ED_50_gamma_imputation <- rgamma(n = 113, shape = SE_PROP_ED_50_gamma$estimate [[1]], rate = SE_PROP_ED_50_gamma$estimate [[2]])
min(SE_PROP_ED_50_gamma_imputation)
max(SE_PROP_ED_50_gamma_imputation)
# give this factor a new imputed level
levels(full_dataset_reduced$AI_ERROR_TYPE) <- c("CI_95", "n/a", "SE", "imputed")
levels(full_dataset_reduced$FORM_ERROR_TYPE) <- c("CI_95", "n/a", "SE", "imputed")
imputed_data <- list()
imputed_model <- list()
imputed_vcv <- list()
for (h in 1:101) {
message(paste0("Now running model ", h, sep = ""))
dat <- full_dataset_reduced
SE_PROP_ED_50_gamma_imputation <- rgamma(n = 113, shape = SE_PROP_ED_50_gamma$estimate [[1]], rate = SE_PROP_ED_50_gamma$estimate [[2]])
# fill in n/a in missing_se with imputed values
# explanation of code below
# if error is missing fill it in with mean*imputed value
# only cycle imputed value if error_type == "n/a"
# once error blank has been filled change error type to imputed
k <- 0
for (i in 1:nrow(dat)) {
if (dat$AI_ERROR_TYPE [i] == "n/a") {
k <- k + 1
}
for (j in k:length(SE_PROP_ED_50_gamma_imputation)) {
if (dat$AI_ERROR_TYPE [i] == "n/a") {
dat$AI_SE_INDIVIDUAL [i] <- dat$AI_50 [i] * SE_PROP_ED_50_gamma_imputation [j]
dat$AI_ERROR_TYPE [i] <- "imputed"
}
}
}
# retaining the k value do the same of for FORM
for (i in 1:nrow(dat)) {
if (dat$FORM_ERROR_TYPE [i] == "n/a") {
k <- k + 1
}
for (j in k:length(SE_PROP_ED_50_gamma_imputation)) {
if (dat$FORM_ERROR_TYPE [i] == "n/a") {
dat$FORM_SE_INDIVIDUAL [i] <- dat$FORM_50 [i] * SE_PROP_ED_50_gamma_imputation [j]
dat$FORM_ERROR_TYPE [i] <- "imputed"
}
}
}
dat$LRR_VAR_INDIVIDUAL <- (dat$FORM_SE_INDIVIDUAL^2 / dat$FORM_50^2) + (dat$AI_SE_INDIVIDUAL^2 / dat$AI_50^2)
imputed_data [[h]] <- dat
imputed_vcv [[h]] <- vcalc(vi = imputed_data [[h]]$LRR_VAR_INDIVIDUAL,
cluster = MULTIPLE_MEASUREMENT,
time1 = TIME_SIMPLE,
phi= 0.8,
data= imputed_data [[h]])
imputed_model [[h]] <- rma.mv(yi = LRR, V = imputed_vcv [[h]],
mod = ~ 0 + PESTICIDE_CLASS,
random = list(~1 | STUDY_ID,
~ TIME_SIMPLE | MULTIPLE_MEASUREMENT),
struct = "AR",
data = imputed_data [[h]], method = "REML", test = "t", dfs = "contain")
}
# what is the median model in terms of herbicide LRR estimate?
median_imputed_model_index <- imputation_results_moderator_level [order(imputation_results_moderator_level$herb_est), ] [2, colnames(imputation_results_moderator_level) == "IMPUTATION_ROUND"]
imputation_results_moderator_level <- lapply(imputed_model, function(x) est.func(x)) %>% bind_rows
est.func <- function(mod) {
df <- data.frame(est = mod$b, lower = mod$ci.lb, upper = mod$ci.ub)
df <- matrix(t(as.matrix(df)), nrow = 1)
df <- as.data.frame(df)
return(df)
}
imputation_results_moderator_level <- lapply(imputed_model, function(x) est.func(x)) %>% bind_rows
median_imputed_model <- imputed_model [[2]]
median_imputed_data <- imputed_data [[2]]
summary(median_imputed_model)
median_imputed_model <- imputed_model [[2]]
median_imputed_data <- imputed_data [[2]]
median_imputed_data
cbind(median_imputed_data$LRR_VAR_INDIVIDUAL, imputed_data [[1]]$LRR_VAR_INDIVIDUAL)
median_imputed_model <- imputed_model [[2]]
median_imputed_data <- imputed_data [[2]]
# compare estimates
est.func <- function(mod) {
df <- data.frame(est = mod$b, lower = mod$ci.lb, upper = mod$ci.ub)
df <- matrix(t(as.matrix(df)), nrow = 1)
df <- as.data.frame(df)
colnames(df) <- c("alg_est", "alg_lower", "alg_upper",
"fung_est", "fung_lower", "fung_upper",
"herb_est", "herb_lower", "herb_upper",
"ins_est", "ins_lower", "ins_upper")
return(df)
}
# with imputed data
summary(median_imputed_model)
robust(median_imputed_model, cluster = median_imputed_data$STUDY_ID, clubSandwich = TRUE)
# without imputed data
final_model <- rma.mv(yi = LRR, V = autocorrelation_matrix,
mod = ~ 0 + PESTICIDE_CLASS,
random = list(~1 | STUDY_ID,
~ TIME_SIMPLE | MULTIPLE_MEASUREMENT),
struct = "AR",
data = full_data_red_no_sim, method = "REML", test = "t", dfs = "contain")
summary(final_model)
# use kable and kableExtra on this
imputed_non_imputed_table_df <- bind_rows(est.func(final_model), est.func(median_imputed_model))
imputed_non_imputed_table_df <- bind_cols(c("final", "imputed"), imputed_non_imputed_table_df)
knitr::kable(imputed_non_imputed_table_df,
"html",
digits = 4,
col.names = c("sample size", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 1, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
# non-imputed data without glyphosate
non_imputed_no_glyphosate_df <- full_data_red_no_sim [(full_data_red_no_sim$AI_NAME != "glyphosate") & (full_data_red_no_sim$AI_NAME != "glyphosate-IPA"), ]
autocorrelation_matrix_no_gly <- vcalc(vi = non_imputed_no_glyphosate_df$LRR_VAR_INDIVIDUAL,
cluster = MULTIPLE_MEASUREMENT,
time1 = TIME_SIMPLE,
phi= 0.8,
data= non_imputed_no_glyphosate_df)
non_imputed_no_glyphosate_model <- rma.mv(yi = LRR, V = autocorrelation_matrix_no_gly,
mod = ~ 0 + PESTICIDE_CLASS,
random = list(~1 | STUDY_ID,
~ TIME_SIMPLE | MULTIPLE_MEASUREMENT),
struct = "AR",
data = non_imputed_no_glyphosate_df, method = "REML", test = "t", dfs = "contain")
summary(non_imputed_no_glyphosate_model)
robust(non_imputed_no_glyphosate_model, cluster = non_imputed_no_glyphosate_df$STUDY_ID, clubSandwich = TRUE)
# use kable and kableExtra on this
gly_no_gly_table_df <- bind_rows(est.func(final_model), est.func(non_imputed_no_glyphosate_model))
gly_no_gly_table_df <- bind_cols(c("final", "- glyphosate"), gly_no_gly_table_df)
knitr::kable(gly_no_gly_table_df,
"html",
digits = 4,
col.names = c(" ", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 1, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
# non-imputed
non_imputed_guidelines_df <- full_data_red_no_sim [full_data_red_no_sim$REGULATORY_STANDARDISED_GUIDELINES_FOLLOWED == "YES", ]
autocorrelation_matrix_guidelines_non_imputed <- vcalc(vi = non_imputed_guidelines_df$LRR_VAR_INDIVIDUAL,
cluster = MULTIPLE_MEASUREMENT,
time1 = TIME_SIMPLE,
phi= 0.8,
data= non_imputed_guidelines_df)
non_imputed_guidelines_model <- rma.mv(yi = LRR, V = autocorrelation_matrix_guidelines_non_imputed,
mod = ~ 0 + PESTICIDE_CLASS,
random = list(~1 | STUDY_ID,
~ TIME_SIMPLE | MULTIPLE_MEASUREMENT),
struct = "AR",
data = non_imputed_guidelines_df, method = "REML", test = "t", dfs = "contain")
summary(non_imputed_guidelines_model)
robust(non_imputed_guidelines_model, cluster = non_imputed_guidelines_df$STUDY_ID, clubSandwich = TRUE)
# use kable and kableExtra on this
full_guide_table_df <- bind_rows(est.func(final_model), est.func(non_imputed_guidelines_model))
full_guide_table_df <- bind_cols(c("final", "guidelines"), full_guide_table_df)
knitr::kable(full_guide_table_df,
"html",
digits = 4,
col.names = c(" ", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 1, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
# non-imputed
non_imputed_sprays_df <- full_data_red_no_sim [(full_data_red_no_sim$FORMULATION_TYPE != "dustable powder") & (full_data_red_no_sim$FORMULATION_TYPE != "granule"), ]
autocorrelation_matrix_sprays_non_imputed <- vcalc(vi = non_imputed_sprays_df$LRR_VAR_INDIVIDUAL,
cluster = MULTIPLE_MEASUREMENT,
time1 = TIME_SIMPLE,
phi= 0.8,
data= non_imputed_sprays_df)
non_imputed_sprays_model <- rma.mv(yi = LRR, V = autocorrelation_matrix_sprays_non_imputed,
mod = ~ 0 + PESTICIDE_CLASS,
random = list(~1 | STUDY_ID,
~ TIME_SIMPLE | MULTIPLE_MEASUREMENT),
struct = "AR",
data = non_imputed_sprays_df, method = "REML", test = "t", dfs = "contain")
summary(non_imputed_sprays_model)
robust(non_imputed_sprays_model, cluster = non_imputed_sprays_df$STUDY_ID, clubSandwich = TRUE)
# use kable and kableExtra on this
full_sprays_table_df <- bind_rows(est.func(final_model), est.func(non_imputed_sprays_model))
full_sprays_table_df <- bind_cols(c("final", "sprays"), full_sprays_table_df)
knitr::kable(full_sprays_table_df,
"html",
digits = 4,
col.names = c(" ", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 1, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
# non-imputed
autocorrelation_matrix_no_influential_imputed <- vcalc(vi = full_dataset_no_influential$LRR_VAR_INDIVIDUAL,
cluster = MULTIPLE_MEASUREMENT,
time1 = TIME_SIMPLE,
phi= 0.8,
data= full_dataset_no_influential)
non_imputed_no_influential_model <- rma.mv(yi = LRR, V = autocorrelation_matrix_no_influential_imputed,
mod = ~ 0 + PESTICIDE_CLASS,
random = list(~1 | STUDY_ID,
~ TIME_SIMPLE | MULTIPLE_MEASUREMENT),
struct = "AR",
data = full_dataset_no_influential, method = "REML", test = "t", dfs = "contain")
summary(non_imputed_no_influential_model)
robust(non_imputed_no_influential_model, cluster = full_dataset_no_influential$STUDY_ID, clubSandwich = TRUE)
# use kable and kableExtra on this
full_final_table_df <- bind_rows(est.func(final_model), est.func(non_imputed_no_influential_model))
full_final_table_df <- bind_cols(c("final", "full"), full_final_table_df)
knitr::kable(full_final_table_df,
"html",
digits = 4,
col.names = c(" ", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 1, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
# non-imputed
autocorrelation_matrix_full_influential_non_imputed <- vcalc(vi = full_dataset$LRR_VAR_INDIVIDUAL,
cluster = MULTIPLE_MEASUREMENT,
time1 = TIME_SIMPLE,
phi= 0.8,
data= full_dataset)
non_imputed_full_model <- rma.mv(yi = LRR, V = autocorrelation_matrix_full_influential_non_imputed,
mod = ~ 0 + PESTICIDE_CLASS,
random = list(~1 | STUDY_ID,
~ TIME_SIMPLE | MULTIPLE_MEASUREMENT),
struct = "AR",
data = full_dataset, method = "REML", test = "t", dfs = "contain")
summary(non_imputed_full_model)
robust(non_imputed_full_model, cluster = full_dataset$STUDY_ID, clubSandwich = TRUE)
# use kable and kableExtra on this
final_influential_table_df <- bind_rows(est.func(final_model), est.func(non_imputed_full_model))
final_influential_table_df <- bind_cols(c("final", "influential"), final_influential_table_df)
knitr::kable(final_influential_table_df,
"html",
digits = 4,
col.names = c(" ", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 1, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
# non-imputed
non_imputed_animals_df <- full_data_red_no_sim [full_data_red_no_sim$SPECIES_KINGDOM == "Animalia", ]
autocorrelation_matrix_animals_non_imputed <- vcalc(vi = non_imputed_animals_df$LRR_VAR_INDIVIDUAL,
cluster = MULTIPLE_MEASUREMENT,
time1 = TIME_SIMPLE,
phi= 0.8,
data= non_imputed_animals_df)
non_imputed_animals_model <- rma.mv(yi = LRR, V = autocorrelation_matrix_animals_non_imputed,
mod = ~ 0 + PESTICIDE_CLASS,
random = list(~1 | STUDY_ID,
~ TIME_SIMPLE | MULTIPLE_MEASUREMENT),
struct = "AR",
data = non_imputed_animals_df, method = "REML", test = "t", dfs = "contain")
summary(non_imputed_animals_model)
robust(non_imputed_animals_model, cluster = non_imputed_animals_df$STUDY_ID, clubSandwich = TRUE)
# use kable and kableExtra on this
final_animal_table_df <- bind_rows(est.func(final_model), est.func(non_imputed_animals_model))
final_animal_table_df <- bind_cols(c("final", "animalia"), final_animal_table_df)
knitr::kable(final_animal_table_df,
"html",
digits = 4,
col.names = c(" ", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 1, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
# use kable and kableExtra on this
combined_sensitivity_table_df <- bind_rows(est.func(final_model),
est.func(median_imputed_model),
est.func(non_imputed_no_glyphosate_model),
est.func(non_imputed_guidelines_model),
est.func(non_imputed_sprays_model),
est.func(non_imputed_animals_model),
est.func(non_imputed_no_influential_model),
est.func(non_imputed_full_model))
combined_sensitivity_table_df <- bind_cols(c("final", "+ imputed", "- glyphosate",
"guidelines", "sprays", "animalia",
"+ >10 CI & microbial community", "+ influential points"), combined_sensitivity_table_df)
knitr::kable(combined_sensitivity_table_df,
"html",
digits = 4,
col.names = c(" ", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 1, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
knitr::kable(combined_sensitivity_table_df,
"html",
digits = 4,
col.names = c(" ", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 1, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
save_kable("output/combined_sensitivity_comparison.pdf")
combined_sensitivity_table_df
final_model
final_model$k
combined_sensitivity_table_df <- bind_cols(c(final_model$k, median_imputed_model$k, non_imputed_no_glyphosate_model$k.all,
non_imputed_guidelines_model$k, non_imputed_sprays_model$k, non_imputed_animals_model$k,
non_imputed_no_influential_model$k, non_imputed_full_model$k), combined_sensitivity_table_df)
combined_sensitivity_table_df
combined_sensitivity_table_df <- combined_sensitivity_table_df [, c(2, 1, 3:ncol(combined_sensitivity_table_df))]
View(combined_sensitivity_table_df)
knitr::kable(combined_sensitivity_table_df,
"html",
digits = 4,
col.names = c(" ", "n", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 1, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
knitr::kable(combined_sensitivity_table_df,
"html",
digits = 4,
col.names = c(" ", "n", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 2, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
knitr::kable(combined_sensitivity_table_df,
"html",
digits = 4,
col.names = c(" ", "n", rep(c("estimate", "lower", "upper"), 4))) %>%
add_header_above(c(" " = 2, "Algaecide" = 3, "Fungicide" = 3, "Herbicide" = 3, "Insecticide" = 3)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
save_kable("output/combined_sensitivity_comparison.pdf")
# with REML
final_model <- rma.mv(yi = LRR, V = autocorrelation_matrix,
mod = ~ 0 + PESTICIDE_CLASS,
random = list(~1 | STUDY_ID,
~ TIME_SIMPLE | MULTIPLE_MEASUREMENT),
struct = "AR",
data = full_data_red_no_sim, method = "REML", test = "t", dfs = "contain")
summary(final_model)
# RVE
robust(final_model, cluster = full_data_red_no_sim$STUDY_ID, clubSandwich = TRUE)
robust(final_model, cluster = full_data_red_no_sim$STUDY_ID, clubSandwich = TRUE)
full_data_red_no_sim [full_data_red_no_sim$PESTICIDE_CLASS =="algaecide", ]
no_algaecides <- full_data_red_no_sim [full_data_red_no_sim$PESTICIDE_CLASS != "algaecide", ]
no_algaecides_autocorrelation_matrix <- vcalc(vi = no_algaecides$LRR_VAR_INDIVIDUAL,
cluster = MULTIPLE_MEASUREMENT,
time1 = TIME_SIMPLE,
phi= 0.8,
data= no_algaecides)
no_algaecides_model <-  rma.mv(yi = LRR, V = no_algaecides_autocorrelation_matrix,
mod = ~ 0 + PESTICIDE_CLASS,
random = list(~1 | STUDY_ID,
~ TIME_SIMPLE | MULTIPLE_MEASUREMENT),
struct = "AR",
data = no_algaecides, method = "REML", test = "t", dfs = "contain")
summary(final_model)
summary(no_algaecides_model)
robust(no_algaecides_model, cluster = no_algaecides$STUDY_ID, clubSandwich = TRUE)
View(full_data_red_no_sim)
predict(final_model)
unique(full_data_red_no_sim$AI_NAME)
sort(unique(full_data_red_no_sim$AI_NAME))
full_data_red_no_sim$AI_NAME <- tidy_up_fun(full_data_red_no_sim$AI_NAME)
sort(unique(full_data_red_no_sim$AI_NAME))
tidy_up_fun()
chicken
